# Замыкания в Python. Вложенные функции
def say_name(name):
    def say_goodbye():
        print("Don`t say me goodbye, " + name + "!")

    return say_goodbye

say_name("Sergey")  # ничего не напечатается, потому что say_goodbye()
                    # ничего не возвращает. Чтобы напечатать текст, созда-
                    # дим ссылку на функцию say_name()
f = say_name("Sergey")
f()  # теперь будет результат
# замыкание - по цепочке держутся окружения. Ф ссылается на окружение say_goodbye()
# say_goodbye() на say_name(), а она в свою очередь - на Ф. Вот и замыкание
f = say_name("Sergey")
f2 = say_name("Python")
f()
f2()
# такой функционал может использоваться для счётчика:
def counter(start = 0):
    def step():
        nonlocal start
        start += 1
        return start
    return step   # counter возвращает сслку на step


c1 = counter(10)
c2 = counter()
print(c1(), c2())
print(c1(), c2())
print(c1(), c2())


def strip_string(strip_chars=" "):
    def do_strip(string):
        return string.strip(strip_chars)

    return do_strip   # strip_string возвращает сслку на do_strip


strip1 = strip_string()
strip2 = strip_string(" !?,.;")
print(strip1(" hello python!.. "))
print(strip2(" hello python!.. "))

######################################################

# Используя замыкания функций, определите вложенную функцию, которая бы увеличивала
# значение переданного параметра на 5 и возвращала бы вычисленный результат. При
# этом внешняя функция должна иметь следующую сигнатуру:
# def counter_add(): ...
# Вызовите функцию counter_add и результат ее работы присвойте переменной с именем
# cnt. Вызовите внутреннюю функцию через переменную cnt со значением k, введенным
# с клавиатуры:
# k = int(input())
# Выведите результат на экран.
#
# def counter_add():
#     def inner(x):
#         return x + 5
#     return inner
#
# k = int(input())
# cnt = counter_add()
# print(cnt(k))

# Используя замыкания функций, объявите внутреннюю функцию, которая увеличивает
# значение своего аргумента на некоторую величину n - параметр внешней функции с
# сигнатурой:
# def counter_add(n): ...
# Вызовите внешнюю функцию counter_add со значением аргумента 2 и результат
# присвойте переменной cnt. Вызовите внутреннюю функцию через переменную cnt
# со значением k, введенным с клавиатуры:
# k = int(input())
# Выведите результат на экран.
#
# def counter_add(n):
#     def inner(x):
#         nonlocal n
#         return x + n
#     return inner
#
# k = int(input())
# cnt = counter_add(2)
# print(cnt(k))

# Используя замыкания функций, объявите внутреннюю функцию, которая заключает в
# тег h1 строку s (s - строка, параметр внутренней функции). Далее, на вход
# программы поступает строка и ее нужно поместить в тег h1 с помощью
# реализованного замыкания. Результат выведите на экран.
# P. S. Пример добавления тега h1 к строке "Python": <h1>Python</h1>
# def test():
#     def inner(s):
#         return "<h1>" + s + "</h1>"
#     return inner
#
#
# s = input()
# t = test()
# print(t(s))

# Используя замыкания функций, объявите внутреннюю функцию, которая заключает
# строку s (s - строка, параметр внутренней функции) в произвольный тег,
# содержащийся в переменной tag - параметре внешней функции.
# Далее, на вход программы поступают две строки: первая с тегом, вторая с
# некоторым содержимым. Вторую строку нужно поместить в тег из первой строки
# с помощью реализованного замыкания. Результат выведите на экран.
# Пример добавления тега h1 к строке "Python": <h1>Python</h1>
# def test(tag="h1"):
#     def inner(s):
#         nonlocal tag
#         return "<" + tag + ">" + s + "</" + tag + ">"
#     return inner
#
# tag = input()
# s = input()
# t = test(tag)
# print(t(s))

# Используя замыкания функций, объявите внутреннюю функцию, которая преобразует
# строку из списка целых чисел, записанных через пробел, либо в список, либо в
# кортеж. Тип коллекции определяется параметром tp внешней функции. Если tp =
# 'list', то используется список, иначе (при другом значении) - кортеж.
# Далее, на вход программы поступают две строки: первая - это значение для
# параметра tp; вторая - список целых чисел, записанных через пробел. С помощью
# реализованного замыкания преобразовать эти данные в соответствующую коллекцию.
# Результат вывести на экран командой (lst - ссылка на коллекцию): print(lst)
#
# def convert(tp='list'):
#     def action(s):
#         nonlocal tp
#         if tp == 'list':
#             lst = [int(x) for x in s.split()]
#             return lst
#         else:
#             lst = tuple(map(int, s.split()))
#             return lst
#     return action
#
# tp = input()
# s = input()
# conv = convert(tp)
# print(conv(s))

#