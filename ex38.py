# Декораторы с параметрами. Сохранение свойств декорируемых функций
import math
from functools import wraps


def df_decorator(dx=0.01):  # декоратор с параметром
    def func_decorator(func):
        @wraps(func)  # можно не писать те строки ниже, а воспользоваться этим декоратором
        def wrapper(x, *args, **kwargs):
            res = (func(x + dx, *args, **kwargs) - func(x, *args, **kwargs)) / dx
            return res

        #wrapper.__doc__ = func.__doc__    # сохранить описание исходной функции
        #wrapper.__name__ = func.__name__  # сохранить имя исходной функции
        return wrapper
    return func_decorator

@df_decorator(dx=0.000001)  # параметр декоратора
def sin_df(x):
    """Функция для вычисления производной функции"""
    return math.sin(x)

#sin_df = df_decorator(dx = 0.0001)(sin_df)  # или так, если не указывать @
df = sin_df(math.pi/3)
print(df)
print(sin_df.__name__)  # выводит имя функции
print(sin_df.__doc__)  # выводит описание работы функции

####################################################################

# Вводится строка целых чисел через пробел. Напишите функцию, которая
# преобразовывает эту строку в список чисел и возвращает их сумму.
# Определите декоратор для этой функции, который имеет один параметр start -
# начальное значение суммы.
# Примените декоратор со значением start=5 к функции и вызовите декорированную
# функцию для введенной строки s:
# s = input()
# Результат отобразите на экране.
def sum_decorator(start=5):
    def get_list_decorator(func):
        def inner(s):
            res = sum(func(s)) + start
            return res
        return inner
    return get_list_decorator


@sum_decorator(start=5)
def get_sum(s):
    return list(map(int, s.split()))

s = "5 6 3 6 -4 6 -1"
print(get_sum(s))

# Объявите функцию, которая возвращает переданную ей строку в нижнем регистре
# (с малыми буквами).
# Определите декоратор для этой функции, который имеет один параметр tag,
# определяющий строку с названием тега и начальным значением "h1". Этот декоратор
# должен заключать возвращенную функцией строку в тег tag и возвращать результат.
# Пример заключения строки "python" в тег h1: <h1>python</h1>
# Примените декоратор со значением tag="div" к функции и вызовите декорированную
# функцию для введенной строки s:
# s = input()
# Результат отобразите на экране.
def to_lower_decorator(tag="h1"):
    def outer(func):
        def inner(s):
            return f"<{tag}>{func(s)}</{tag}>"
        return inner
    return outer


@to_lower_decorator(tag="div")
def to_lower(s):
    return s.lower()


s = "Декораторы - это классно!"
print(to_lower(s))

# Объявите функцию, которая принимает строку на кириллице и преобразовывает ее в
# латиницу, используя следующий словарь для замены русских букв на
# соответствующее латинское написание.
# Функция должна возвращать преобразованную строку. Замены делать без учета
# регистра (исходную строку перевести в нижний регистр - малые буквы).
# Определите декоратор с параметром chars и начальным значением " !?", который
# данные символы преобразует в символ "-" и, кроме того, все подряд идущие дефисы
# (например, "--" или "---") приводит к одному дефису. Полученный результат
# должен возвращаться в виде строки.
# Примените декоратор с аргументом chars="?!:;,. " к функции и вызовите
# декорированную функцию для введенной строки s:
# s = input()
# Результат отобразите на экране.
t = {'ё': 'yo', 'а': 'a', 'б': 'b', 'в': 'v', 'г': 'g', 'д': 'd', 'е': 'e', 'ж': 'zh',
     'з': 'z', 'и': 'i', 'й': 'y', 'к': 'k', 'л': 'l', 'м': 'm', 'н': 'n', 'о': 'o', 'п': 'p',
     'р': 'r', 'с': 's', 'т': 't', 'у': 'u', 'ф': 'f', 'х': 'h', 'ц': 'c', 'ч': 'ch', 'ш': 'sh',
     'щ': 'shch', 'ъ': '', 'ы': 'y', 'ь': '', 'э': 'e', 'ю': 'yu', 'я': 'ya'}

def chars_decorator(chars = "!?"):
    def outer(func):
        def inner(s):
            res = ""
            for i in s:
                if i in chars:
                   res += '-'
                else:
                    res += i
            res = res.replace("---", '-')
            res = res.replace("--", '-')
            return func(res.lower())
        return inner
    return outer

@chars_decorator(chars="?!:;,. ")
def transliteration(s):
    res = ""
    for i in s:
        if t.get(i) is not None:
           res += t.get(i)
        else:
            res += i
    return res


s = "Декораторы - это круто!"
print(transliteration(s))

# Объявите функцию с именем get_list и следующим описанием в теле функции:
# '''Функция для формирования списка целых значений'''
# Сама функция должна формировать и возвращать список целых чисел, который
# поступает на ее вход в виде строки из целых чисел, записанных через пробел.
# Определите декоратор, который выполняет суммирование значений из списка этой
# функции и возвращает результат.
# Внутри декоратора декорируйте переданную функцию get_list с помощью команды
# @wraps (не забудьте сделать импорт: from functools import wraps). Такое
# декорирование необходимо, чтобы исходная функция get_list сохраняла свои
# локальные свойства: __name__ и __doc__.
# Примените декоратор к функции get_list, но не вызывайте ее.

def get_list_decorator(func):
    @wraps(func)
    def inner(s):
        return sum(func(s))
    return inner

@get_list_decorator
def get_list(s):
    """Функция для формирования списка целых значений"""
    return list(map(int, s.split()))

print(get_list("1 2 3 4 5 6 7 8 9 10"))
print(get_list.__name__)  # выводит имя функции
print(get_list.__doc__)  # выводит описание работы функции