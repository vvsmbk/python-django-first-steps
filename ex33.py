# Рекурсивные функции
def recursive(value):
    print(value)
    if value < 4:
        recursive(value+1)
    print(value)    # видим уменьшение значения value.
                    # когда последняя функция в СТЕКЕ завершает работу,
                    # то последние операции в функции после рекурсивного вызова
                    # выполняются в обратном порядке

recursive(1)    # Когда функция вызывается, она хранится в стеке вызова функций.
                # Функции каждый раз помещаются туда, и на 997-й итерации
                # происходит ограничение (переполнение стека).


def factorial(n):
    if n <= 0:
        return 1
    else:
        return n * factorial(n - 1)


print(factorial(6))

#  пример с обходом каталогов и файлов
F = {
    'C' : {
        'Python39': ['python.exe', 'python.ini'],
        'Program Files': {
            'Java' : ['README.txt', 'Welcome.html', 'java.exe'],
            'MATLAB': ['matlab.bat', 'matlab.exe', 'mcc.bat']
        },
        'Windows': {
            'Sytem32': ['acledit.dll', 'aclui.dll', 'zipfldr.dll']
        }
    }
}


def get_files(path, depth=0):
    for f in path:
        print("-"*depth, ">", f)
        if type(path[f]) == dict:
            get_files(path[f], depth+1)
        else:
            print("-"*(depth+1), ">", " ".join(path[f]))


get_files(F)

########################################################

# Вводится целое положительное число N. Необходимо написать рекурсивную
# функцию с именем get_rec_N, которая отображает на экране последовательность
# целых чисел от 1 до N (включительно). Каждое число выводится с новой строки.
# В качестве параметра функция get_rec_N должна принимать одно числовое значение.
# То есть, иметь только один параметр. Начальный вызов функции будет выглядеть
# так:
# get_rec_N(N)
# Вызывать функцию не нужно, только объявить.
# N = int(input())
#
#
# def get_rec_N(N):
#     if N > 1:
#         get_rec_N(N - 1)
#     print(N)
#
#
# get_rec_N(N)

# Вводится список целых чисел в одну строчку через пробел. Необходимо вычислить
# сумму этих введенных значений, используя рекурсивную функцию (для перебора
# элементов списка) с именем get_rec_sum. Функция должна возвращать значение
# суммы. (Выводить на экран она ничего не должна).
# Вызовите эту функцию и выведите вычисленное значение суммы на экран.
# lst = list(map(int, input().split()))
#
#
# def get_rec_sum(lst):
#     if len(lst) > 1:
#         lst[0] += lst.pop(1)
#         return get_rec_sum(lst)
#     return lst[0]
#
#
# print(get_rec_sum(lst))

# водится натуральное число N. Необходимо с помощью рекурсивной функции
# fib_rec(N, f=[]) (здесь N - общее количество чисел Фибоначчи; f - начальный
# список этих чисел) сформировать последовательность чисел Фибоначчи по правилу:
# первые два числа равны 1 и 1, а каждое следующе значение равно сумме двух
# предыдущих. Пример такой последовательности для первых 7 чисел: 1, 1, 2, 3, 5,
# 8, 13, ...
# Функция должна возвращать список сформированной последовательности длиной N.
# Вызывать функцию не нужно, только объявить.
# n = int(input())
#
#
# def fib_rec(N, f=[]):
#     if N == 1:
#         return [1]
#     elif N == 2:
#         return [1, 1]
#     f = fib_rec(N - 1)
#     f.append(f[-1] + f[-2])
#     return f
#
# print(*fib_rec(n))

# Вводится целое неотрицательное число n. Необходимо с помощью рекурсивной
# функции fact_rec вычислить факториал числа n. Напомню, что факториал числа,
# равен: n! = 1 * 2 * 3 *...* n. Функция должна возвращать вычисленное значение.
# Вызывать функцию не нужно, только объявить со следующей сигнатурой: def fact_rec(n): ...
# n = int(input())
#
#
# def fact_rec(n):
#     if n <= 0:
#         return 1
#     else:
#         return n * fact_rec(n - 1)

d = [1, 2,
     [True, False],
     ["Москва", "Уфа",
        [100, 101],
        ['True',
             [-2, -1]
         ]
      ],
     7.89]
# С помощью рекурсивной функции get_line_list создать на его основе одномерный
# список из значений элементов списка d. Функция должна возвращать новый
# созданный одномерный список.  (Только возвращать, выводить на экран ничего не
# нужно.)
# Вызывать функцию не нужно


def get_line_list(d, a=[]):
    for s in d:
        if type(s) == list:
            get_line_list(s, a)
        else:
            a.append(s)
    return a

print(get_line_list(d))


# Лягушка прыгает вперед и может скакнуть либо на одно деление, либо сразу на
# два. Наша задача определить количество вариантов маршрутов, которыми лягушка
# может достичь риски под номером N (натуральное число N вводится с клавиатуры).
# Решать задачу следует с применением рекурсивной функции. Назовем ее get_path.
# Алгоритм решения будет следующий. Рассмотрим, например, риску под номером 4.
# Очевидно, в нее лягушка может скакнуть либо с риски номер 2, либо с риски
# номер 3. Значит, общее число вариантов перемещений лягушки можно определить
# как:
# get_path(4) = get_path(3) + get_path(2)
# Аналогично будет справедливо и для любой риски N:
# get_path(N) = get_path(N-1) + get_path(N-2)
# А начальные условия задачи, следующие:
# get_path(1) = 1
# get_path(2) = 2
# Реализуйте такую рекурсивную функцию, которая должна возвращать количество
# вариантов перемещений лягушки для риски под номером N.
# Вызовите эту функцию для введенного числа N и отобразите результат на экране.

n = 7#int(input())


def get_path(n):
    if n == 1:
        return 1
    elif n == 2:
        return 2
    else:
        return get_path(n - 1) + get_path(n - 2)


print(get_path(n))

