# dict methods
lst = ["+7", "+6", "+5", "+4"]
a = dict.fromkeys(lst)  # create keys in a with lst values
print(a)

a = dict.fromkeys(lst, "country code")  # create keys in a with lst values
print(a)
a.clear()   # clears a
print(a)
d = {True: 1, False: "False", 'list': [1, 2, 3], 5: 5}
d2 = d  # not a copy, but link
d2 = d.copy()
d2['list'] = [5,6,7]
print(d, "\n", d2)
print(d.get('list'))    # returns values for specified key or None if doesn`t exist
print(d.get('33', 'Не существует'))
d.setdefault(3) # sets default value for specified key, or creates key with None value
print(d)
d.pop(3, "Удалена пара ключ-значение (3)")
d.setdefault(3, "Three")
print(d)
d.popitem()  # удаляет СЛУЧАЙНЫЙ элмент (чаще всего - последний), т.к. только
             # с пайтон 3.7 словарь - упорядоченная коллекция
print(d.keys())  # returns list of all keys
for x in d:
    print(x)     # like d.keys()

print(d.values())  # returns list of all values
for x in d.values():
    print(x)     # like d.values()

for x in d.items():
    print(x)     # возращает кортежи (!) ключ-значение

for key, value in d.items():
    print(f"key: {key}; value:{value}")

d = dict(one=1, two=2, three='3', four='4')
d2 = {2 : 'good', 3: 'nice', 'four': 'OK', 5:'Well done'}
d.update(d2)    # если ключи совпали, то значение перезаписывается
print(d)

d = dict(one=1, two=2, three='3', four='4')
d = {**d, **d2}  # объединяет оба словаря, ключи перезаписываются
# (второй добавился к первому, значит значения ключей берутся из него)
print(d)
d = dict(one=1, two=2, three='3', four='4')
# d = d2 | d  # эквивалентно d = {**d2, **d}, появилось в пайтон 3.9
print(d)

###########################################################
#Вводится строка из русских букв и символов пробела. Необходимо ее закодировать
# азбукой Морзе, где каждой букве ставится в соответствие код из точки и тире.
# После каждой закодированной буквы должен стоять пробел (символ окончания кода
# буквы). После последнего кода пробела быть не должно (в конце строки). Коды
# азбуки Морзе приведены ниже для русского алфавита и символа пробела:
# d = {' ': '-...-', 'А': '.-', 'Б': '-...', 'В': '.--', 'Г': '--.',
#      'Д': '-..', 'Е': '.', 'Ж': '...-', 'З': '--..', 'И': '..', 'Й': '.---',
#      'К': '-.-', 'Л': '.-..', 'М': '--', 'Н': '-.', 'О': '---', 'П': '.--.',
#      'Р': '.-.', 'С': '...', 'Т': '-', 'У': '..-', 'Ф': '..-.', 'Х': '....',
#      'Ц': '-.-.', 'Ч': '---.', 'Ш': '----', 'Щ': '--.-', 'Ъ': '--.--', 'Ы':
#          '-.--', 'Ь': '-..-', 'Э': '..-..', 'Ю': '..--', 'Я': '.-.-'}
#Результат кодирования вывести в виде строки.
# s = input()
# res = ""
# for letter in s:
#     letter = letter.upper()
#     res += d.get(letter)
#     res += ' '
# print(res[:-1])

#Имеется закодированная строка с помощью азбуки Морзе. Коды разделены между
# собой пробелом. Необходимо ее раскодировать, используя азбуку Морзе из
# предыдущего занятия. Полученное сообщение (строку) вывести на экран.
# message = input().split(' ')
# res = ""
# for x in message:
#     for key, value in d.items():
#         if x == value:
#             res += key
# print(res.lower())

#Вводится список целых чисел в одну строчку через пробел. С помощью словаря
# выделите только уникальные (не повторяющиеся) введенные значения и, затем,
# сформируйте список из уникальных чисел. Выведите его на экран в виде набора
# чисел, записанных через пробел.
#P. S. Такая задача, обычно решается через множества, но мы их еще не
# проходили, поэтому воспользуемся словарем.
# lst = list(map(int, input().split()))
# d = dict.fromkeys(lst)
# print(*d.keys())

# Вводятся данные в формате: <день рождения N> имя_N
# Дни рождений и имена могут повторяться. На их основе сформировать
# словарь и вывести его в формате (см. пример ниже):день рождения M: имя1,
# ..., имяNM
# lst_in = ["3 Сергей", "5 Николай", "4 Елена", "7 Владимир", "5 Юлия", "4 Светлана"]
# lst_in = [list(x.split()) for x in lst_in]
# d = {}
# for el in lst_in:
#     if d.get(el[0]) != None:
#          d[el[0]].append(el[1])
#     else:
#          d.setdefault(el[0], [el[1]])
# for k, v in d.items():
#
#     print(f"{int(k)}: {', '.join(v)}")

things = {'карандаш': 20, 'зеркальце': 100, 'зонт': 500, 'рубашка': 300,
          'брюки': 1000, 'бумага': 200, 'молоток': 600, 'пила': 400, 'удочка': 1200,
          'расческа': 40, 'котелок': 820, 'палатка': 5240, 'брезент': 2130, 'спички': 10}
#Сергей собирается в поход и готов взвалить на свои хрупкие плечи
# максимальный вес в N кг (вводится с клавиатуры). Он решил класть в
# рюкзак предметы в порядке убывания их веса (сначала самые тяжелые,
# затем, все более легкие) так, чтобы их суммарный вес не превысил значения
# N кг. Все предметы даны в единственном экземпляре. Выведите список
# предметов (в строчку через пробел), которые берет с собой Сергей в
# порядке убывания их веса.
#P. S. 1 кг = 1000 грамм
n = int(input())
n *= 1000
res = {}
things = dict(sorted(things.items(), key=lambda item: item[1], reverse=True))
for k, v in things.items():
    if n >= v:
        res.setdefault(k, v)
        n -= v
print(' '.join(res.keys()))