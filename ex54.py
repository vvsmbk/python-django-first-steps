# Функции isinstance и type для проверки типов данных
# isinstance(объект, тип данных) -> True|False
a = 5
print(isinstance(a, int))  # проверка с учетом иерархии объектов
a = True
print(isinstance(a, bool))
print(isinstance(a, int))  # bool наследуется от int, поэтому True
print(type(a) == bool, type(a) == int)  # строгая проверка

# посчитать сумму только вещественных чисел
data = (4.5, 8.7, True, "book", 8, 10, -11, [True, False])
s = 0
for x in data:
    if isinstance(x, float):
        s += x
print(s)

# реализация с помощью фильтра
s = sum(filter(lambda x: isinstance(x, float), data))
print(s)
# значение будет неверно, так как bool воспринимается как int
s = sum(filter(lambda x: isinstance(x, int), data))
print(s)
# поэтому:
s = sum(filter(lambda x: type(x) == int, data))
print(s)

a = 5.5
print(isinstance(a, (int, float)))


################################
# Определите функцию с именем get_add, которая складывает или
# два числа или две строки (но не число со строкой) и
# возвращает полученный результат. Если сложение не может
# быть выполнено, то функция возвращает значение None.
# Сигнатура функции должна быть, следующей:
# def get_add(a, b): ...
# Вызывать функцию не нужно, только определить. Также ничего
# не нужно выводить на экран.
# P. S. Не забудьте про необходимость различения булевых
# значений (False, True) от целочисленных.
def get_add(a, b):
    if type(a) in (int, float) and type(b) in (int, float):
        return a + b
    elif isinstance(a, str) and isinstance(b, str):
        return a + b
    else:
        return None


# пределите функцию с именем get_sum, которая принимает на
# входе итерируемый объект (список, строку, кортеж, словарь,
# множество) и вычисляет сумму только целых чисел, взятых из
# элементов итерируемого объекта. Вычисленная сумма
# возвращается функцией. Если целых чисел нет, то возвращается
# 0.
# Сигнатура функции должна быть, следующей:
# def get_sum(it): ...
# Вызывать функцию не нужно, только определить. Также ничего
# не нужно выводить на экран.
# Примеры входного аргумента функции:
# get_sum([1,2,3, "a", True, [4, 5], "c", (4, 5)])
# get_sum({5, 6, 7, '8', 5, '4'})
# get_sum((10, "f", '33', True, 12))
# get_sum(['1', True, False, (1, 23)])
# P. S. Не забудьте про необходимость различения булевых
# значений (False, True) от целочисленных.

def get_sum(it):
    s = 0
    for x in it:
        if type(x) == int:
            s += x
    return s


# Определите функцию с именем get_even_sum, которая принимает
# на входе итерируемый объект (список, строку, кортеж, словарь,
# множество) и вычисляет сумму только целых четных чисел,
# взятых из элементов итерируемого объекта. Результат
# возвращается функцией. Если целых чисел нет, то возвращается
# 0.
# Cигнатура функции должна быть, следующей:
# def get_even_sum(it): ...
# Вызывать функцию не нужно, только определить. Также ничего
# не нужно выводить на экран.
# P. S. Не забудьте про необходимость различения булевых
# значений (False, True) от целочисленных.

def get_even_sum(it):
    s = 0
    for x in it:
        if type(x) == int and x % 2 == 0:
            s += x
    return s


# Определите функцию с именем get_list_dig, которая возвращает
# список только из числовых значений переданной ей коллекции
# (список или кортеж).
# Сигнатура функции должна быть, следующей:
# def get_list_dig(lst): ...
# Вызывать функцию не нужно, только определить. Также ничего
# не нужно выводить на экран.
# P. S. Не забудьте про необходимость различения булевых
# значений (False, True) от целочисленных.
def get_list_dig(it):
    s = []
    for x in it:
        if type(x) == int or type(x) == float:
            s.append(x)
    return s
