# декораторы функций
def func_decorator(func):   # универсальная функция-декоратор для функции
    def wrapper(*args, **kwargs):
        print("----------что-то происходит до вызова функции-----------")
        res = func(*args, **kwargs)
        print("----------что-то происходит после вызова функции-----------")
        return res
    return wrapper

# вызовем неявно декоратор
@func_decorator
def some_func(title, tag):
    print(f"title = {title}, tag = {tag}")
    return f"<{tag}>{title}</{tag}>"


# some_func = func_decorator(some_func) # теперь не просто some_func работает, её
# функционал как бы расширен
some_func("Пайтон навсегда", "h1")
res = some_func("Пайтон навсегда!", "h1")
print(res)

#########################################################################

# Объявите функцию с именем get_sq, которая вычисляет площадь прямоугольника по
# двум параметрам: width и height - ширина и высота прямоугольника. И возвращает
# результат (сама ничего на экран не выводит). То есть, функция имеет сигнатуру:
# def get_sq(width, height): ...
# Определите декоратор func_show для этой функции, который отображает результат
# на экране в виде строки (без кавычек):
# "Площадь прямоугольника: <значение>"
# Вызывать функцию и декоратор не нужно, только объявить. Применять декоратор к
# функции также не нужно.
# def func_show(func):
#     def inner(w, h):
#         print(f"Площадь прямоугольника: {func(w, h)}")
#     return inner
#
#
# def get_sq(width, height):
#     return width * height

# На вход программы поступает строка с названиями пунктов меню, записанные в одну
# строчку через пробел. Необходимо задать функцию с именем get_menu, которая
# преобразует эту строку в список из слов и возвращает этот список. Сигнатура
# функции, следующая:
# def get_menu(s): ...
# Определите декоратор для этой функции с именем show_menu, который отображает
# список на экран в формате:
# 1. Пункт_1
# 2. Пункт_1
# ...
# N. Пункт_N
# Примените декоратор show_menu к функции get_menu, используя оператор @. Более
# ничего в программе делать не нужно. Сами функции не вызывать.
# def show_menu(func):
#     def inner(s):
#         lst = func(s)
#         for index, value in enumerate(lst):
#             print(f"{index + 1}. {value}")
#     return inner
#
# @show_menu
# def get_menu(s):
#     return list(s.split())
#
#
# s = "Главная Добавить Удалить Выйти"
# f = get_menu(s)

# На вход программы поступает строка из целых чисел, записанных через пробел.
# Напишите функцию get_list, которая преобразовывает эту строку в список из целых
# чисел и возвращает его. Определите декоратор для этой функции, который сортирует
# список чисел по возрастанию. Результат сортировки должен возвращаться при вызове
# декоратора.
# Вызовите декорированную функцию get_list и отобразите полученный отсортированный
# список lst командой: print(*lst)
def sort_decorator(func):
    def inner(s):
        lst = func(s)
        lst.sort()
        return lst
    return inner

@sort_decorator
def get_list(s):
    return list(map(int, s.split()))

s = "8 11 -5 4 3 10"
print(*get_list(s))


# Вводятся две строки из слов (слова записаны через пробел). Объявите функцию,
# которая преобразовывает эти две строки в два списка слов и возвращает эти
# списки.
# Определите декоратор для этой функции, который из двух списков формирует
# словарь, в котором ключами являются слова из первого списка, а значениями -
# соответствующие элементы из второго списка. Полученный словарь должен
# возвращаться при вызове декоратора.
# Примените декоратор к первой функции и вызовите ее для введенных строк.
# Результат (словарь d) отобразите на экране командой:
# print(*sorted(d.items()))
# def lst_to_dict(func):
#     def inner(s1, s2):
#         lst1, lst2 = func(s1, s2)
#         d = dict()
#         for i in range(len(lst1)):
#             d[lst1[i]] = lst2[i]
#         return d
#     return inner
#
# @lst_to_dict
# def get_list(s1, s2):
#     return list(s1.split()), list(s2.split())
#
#
# s1 = input()
# s2 = input()
# print(*sorted(get_list(s1, s2).items()))

# Объявите функцию, которая принимает строку на кириллице и преобразовывает ее в
# латиницу, используя следующий словарь для замены русских букв на
# соответствующее латинское написание:
t = {'ё': 'yo', 'а': 'a', 'б': 'b', 'в': 'v', 'г': 'g', 'д': 'd', 'е': 'e', 'ж': 'zh',
     'з': 'z', 'и': 'i', 'й': 'y', 'к': 'k', 'л': 'l', 'м': 'm', 'н': 'n', 'о': 'o', 'п': 'p',
     'р': 'r', 'с': 's', 'т': 't', 'у': 'u', 'ф': 'f', 'х': 'h', 'ц': 'c', 'ч': 'ch', 'ш': 'sh',
     'щ': 'shch', 'ъ': '', 'ы': 'y', 'ь': '', 'э': 'e', 'ю': 'yu', 'я': 'ya', '!': '!'}
# Функция должна возвращать преобразованную строку. Замены делать без учета
# регистра (исходную строку перевести в нижний регистр - малые буквы). Все
# небуквенные символы ": ;.,_" превращать в символ '-' (дефиса).
# Определите декоратор для этой функции, который несколько подряд идущих дефисов,
# превращает в один дефис. Полученная строка должна возвращаться при вызове
# декоратора. (Сам декоратор на экран ничего выводить не должен).
# Примените декоратор к первой функции и вызовите ее для введенной строки s на
# кириллице: s = input()
# Результат работы декорированной функции отобразите на экране.
def remove_tire(func):
    def inner(s):
        res = func(s)
        res = res.replace("---", "-")
        res = res.replace("--", "-")
        return res
    return inner


@remove_tire
def get_translated(s):
    z = [':', ';', ' ', '.', ',', '_', '"','-']
    res = ""
    for i in s.lower():
        if z.count(i) > 0:
            res += '-'
        elif t.get(i) is not None:
            res += t.get(i)
        else:
            res += i
    return res


s = "Python - это круто!"
print(get_translated(s))